---
layout:     post
title:      Ethereum's Recursive Length Prefix encoding in Elixir
date:       2018-04-29
summary:    Implementing RLP with recursive protocols
categories: elixir
---

![eth_rlp](https://i.imgur.com/63UR6fU.png)

### Introduction

This week we, at Mana project, rewrote our implementation of Ethereum's Recursive Length Prefix (RLP) encoding so now encoding is completely done recursively using Elixir's protocols. I think it's a good opportunity to describe RLP and its implementation details.

### Background

Recursive Length Prefix is Ethereum's homebrew binary encoding that extensively used from [Merkle Paticia Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree) (keys are encoded with RLP) to peer-to-peer communications between nodes with [RLPx](https://github.com/ethereum/devp2p/blob/master/rlpx.md) (message data are encoded with RLP).

##### Why was RLP chosen as common encoding algorithm in Ethereum?

From Ethereum's design rationale:

<blockquote>
  <p>
  RLP is intended to be a highly minimalistic serialization format; its sole purpose is to store nested arrays of bytes. Unlike protobuf, BSON and other existing solutions, RLP does not attempt to define any specific data types such as booleans, floats, doubles or even integers; instead, it simply exists to store structure, in the form of nested arrays, and leaves it up to the protocol to determine the meaning of the arrays
  </p>
  <footer><cite title="rationale">Ethereum's design rationale</cite></footer>
</blockquote>

Advantages of RLP:

- simplicity of implementation
- guaranteed absolute byte-perfect consistency

### Implementation

First I'll provide formal definition of RLP from Ethereum's Yellow Paper, then I'll show how it corresponds to our implementation and finally I'll describe how to encode custom types.

##### Definition from the Yellow Paper

We define the RLP function as RLP through two sub-functions, the first handling the instance when the value is a byte array, the second when it is a sequence of further values.

If the value to be serialised is a byte-array, the RLP serialisation takes one of three forms:
- If the byte-array contains solely a single byte and that single byte is less than 128, then the input is exactly equal
to the output.
- If the byte-array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to
the length of the byte array plus 128.
- Otherwise, the output is equal to the input prefixed by the minimal-length byte-array which when interpreted as
a big-endian integer is equal to the length of the input byte array, which is itself prefixed by the number of bytes
required to faithfully encode this length value plus 183.

If RLP is used to encode a scalar, defined only as a positive integer, it must be specified as the shortest byte array such that the big-endian interpretation of it is equal.

If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:
- If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal
to that concatenation prefixed by the byte equal to the length of this byte array plus 192.
- Otherwise, the output is equal to the concatenated serialisations prefixed by the minimal-length byte-array which
when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which
is itself prefixed by the number of bytes required to faithfully encode this length value plus 247.

##### Protocols

From formal definiton we see that there are three different variants. They are:
- Encoding byte-arrays.
- Encoding positive integers.
- Encoding sequences of other items.

In our implementation for each of these variants we define separate protocol.

###### Integers

So let's start with the simplest one, protocol for integers:

```elixir
defimpl ExRLP.Encode, for: Integer do
  alias ExRLP.Encode

  @spec encode(ExRLP.t()) :: binary()
  def encode(value) when value >= 0 do
    value
    |> to_binary()
    |> Encode.encode()
  end

  @spec to_binary(integer()) :: binary()
  defp to_binary(object) when is_integer(object) and object == 0 do
    ""
  end

  defp to_binary(object) when is_integer(object) and object > 0 do
    object |> :binary.encode_unsigned()
  end
end
```

Protocol for integers is a subset of protocol for binaries. It converts number to binary and encodes it with protocol binaries.

###### Binaries

As we can see in formal definition there are three situations encoding binaries and thanks to Elixir's syntax they can be concisely described in programming code using guard clauses and pattern matching:

```elixir
defimpl ExRLP.Encode, for: BitString do
  @spec encode(ExRLP.t()) :: binary()
  def encode(value) do
    value |> encode_item
  end

  @spec encode_item(binary()) :: binary()
  defp encode_item(<<byte>> = item) when byte_size(item) == 1 and byte < 128 do
    item
  end

  defp encode_item(item) when is_binary(item) and byte_size(item) < 56 do
    prefix = 128 + byte_size(item)

    <<prefix>> <> item
  end

  defp encode_item(item) when is_binary(item) do
    be_size = item |> Utils.big_endian_size()
    byte_size = be_size |> byte_size

    <<183 + byte_size>> <> be_size <> item
  end
end
```

###### Lists

```elixir

defimpl ExRLP.Encode, for: List do
  alias ExRLP.{Utils, Encode}

  @spec encode([ExRLP.t()]) :: binary()
  def encode(values) do
    values
    |> encode_items("")
  end

  @spec encode_items([ExRLP.t()], binary()) :: binary()
  defp encode_items([], acc) do
    acc |> prefix_list
  end

  defp encode_items([item | tail], acc) do
    encoded_item = item |> Encode.encode()

    tail |> encode_items(acc <> encoded_item)
  end

  @spec prefix_list(binary()) :: binary()
  defp prefix_list(encoded_concat) when byte_size(encoded_concat) < 56 do
    size = encoded_concat |> byte_size

    <<192 + size>> <> encoded_concat
  end

  defp prefix_list(encoded_concat) do
    be_size = encoded_concat |> Utils.big_endian_size()
    byte_size = be_size |> byte_size

    <<247 + byte_size>> <> be_size <> encoded_concat
  end
end
```
